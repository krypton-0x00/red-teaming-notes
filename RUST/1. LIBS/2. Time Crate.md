|Type|Purpose|
|---|---|
|`Date`|Just a calendar date (year, month, day).|
|`Time`|Just a time of day (hour, minute, second, etc.).|
|`PrimitiveDateTime`|Date + time, **without** timezone.|
|`OffsetDateTime`|Date + time **with** a UTC offset.|
|`Duration`|A span of time (seconds, minutes, hours, days).|
|`Month`, `Weekday`|Enum representations of months and days of the week.|
## Basics
```rust
use time::{Date, Month, Time};

fn main() {
    let date = Date::from_calendar_date(2025, Month::August, 10).unwrap();
    let time = Time::from_hms(6, 30, 0).unwrap();

    println!("Date: {date}"); //Date: 2025-08-10
    println!("Time: {time}"); //Time: 6:30:00.0

    let naive_date = PrimitiveDateTime::new(date, time);
    println!("NAIVE DATE : {naive_date}"); //NAIVE DATE : 2025-08-10 6:30:00.0

    // Current time in UTC
    let now = OffsetDateTime::now_utc();

}
```


## Duration Math

```rust
    let duration = Duration::hours(5) + Duration::minutes(30);
    println!("Duration: {duration}"); //Duration: 5h30m
```

```rust
let later = naive_dt + duration;
let earlier = naive_dt - Duration::days(7);
let diff = later - naive_dt; // gives a Duration
```

## Parsing Strings into Date/Time

```rust
use time::{PrimitiveDateTime, format_description};

let format = format_description::parse("[year]-[month]-[day] [hour]:[minute]:[second]").unwrap();
let dt = PrimitiveDateTime::parse("2025-08-10 06:30:00", &format).unwrap();

```

## Usefull Helpers

```rust
let y = naive_dt.year();
let m = naive_dt.month();
let d = naive_dt.day();
let weekday = naive_dt.weekday();

```

## Leap Year check 

```rust
assert!(Date::from_calendar_date(2024, Month::February, 29).is_ok());
```

## Performance Tip

If you need **many parses with the same format**, compile the format once:

```rust
static FORMAT: once_cell::sync::Lazy<Vec<time::format_description::FormatItem<'static>>> =
    once_cell::sync::Lazy::new(|| {
        format_description::parse("[year]-[month]-[day] [hour]:[minute]:[second]").unwrap()
    });

```
