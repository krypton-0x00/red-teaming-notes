## **The problem UFCS solves**

In Rust, methods are just _syntax sugar_ for functions defined in traits or `impl` blocks.

```rust
obj.method();

// RUST Secreetly calling something like this 
TypeName::method(&obj);
//But sometimes, there are **name collisions** or **multiple traits with the same method name.  

// In those cases, Rust can’t guess which one you mean. That’s when **UFCS** comes in.
```


```rust
struct MyType;

trait TraitA {
    fn hello(&self);
}

trait TraitB {
    fn hello(&self);
}

impl TraitA for MyType {
    fn hello(&self) {
        println!("Hello from TraitA!");
    }
}

impl TraitB for MyType {
    fn hello(&self) {
        println!("Hello from TraitB!");
    }
}

fn main() {
    let obj = MyType;

    // obj.hello(); // ❌ ERROR: Rust doesn't know which hello you mean.

    // ✅ Use UFCS to pick:
    <MyType as TraitA>::hello(&obj);
    <MyType as TraitB>::hello(&obj);
}


```