## **The problem UFCS solves**

In Rust, methods are just _syntax sugar_ for functions defined in traits or `impl` blocks.

```rust
obj.method();

// RUST Secreetly calling something like this 
TypeName::method(&obj);
//But sometimes, there are **name collisions** or **multiple traits with the same method name.  

// In those cases, Rust can’t guess which one you mean. That’s when **UFCS** comes in.
```

### Quick Example

```rust
#[derive(Debug)]
pub struct Person {
    pub name: String,
}
impl Person {
    fn new(name: String) -> Self {
        Self { name }
    }
    fn update(&mut self, name: String) {
        self.name = name;
    }
}
fn main() {
    let mut p1 = Person::new("shakir".to_string());

    Person::update(&mut p1, "aamir".to_string());  //we can use this syntax
    dbg!(&p1);
}
```

## UFCS with Enums

```rust
enum Status {
    Active,
    Inactive,
}

impl Status {
    fn print(&self) {
        println!("{:?}", self);
    }
}

fn main() {
    let s = Status::Active;
    Status::print(&s); // UFCS — explicit call
}

```
## But what if 2 traits have function with same name?

#### This is where UFCS Comes into play.q

```rust
struct MyType;

trait TraitA {
    fn hello(&self);
}

trait TraitB {
    fn hello(&self);
}

impl TraitA for MyType {
    fn hello(&self) {
        println!("Hello from TraitA!");
    }
}

impl TraitB for MyType {
    fn hello(&self) {
        println!("Hello from TraitB!");
    }
}

fn main() {
    let obj = MyType;

    // obj.hello(); // ❌ ERROR: Rust doesn't know which hello you mean.

    // ✅ Use UFCS to pick:
    <MyType as TraitA>::hello(&obj);
    <MyType as TraitB>::hello(&obj);
}


```