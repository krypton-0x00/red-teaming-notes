## Binary Conversion
```python
if num < 0:
	is_neg = True
	num = abs(num)
else:
	is_neg = False
result = ''
if num == 0:
	result = '0'
while num > 0:
	result = str(num%2) + result
	num = num//2
if is_neg:
	result = '-' + result
```

```OUTPUT
Num> 19
10011

Num> -19
-10011
```


## **Part 1 – The Motivation**

**Code from the slides:**

```python
x = 0

for i in range(10):
    x += 0.1

print(x == 1)
print(x, '==', 10*0.1)
```

### Step-by-step:

1. We start with `x = 0`.
2. We add `0.1` to it **10 times**.

   * In math, `0.1 × 10 = 1.0`.
   * But in Python floats, `0.1` is actually stored as:

     ```
     0.1000000000000000055511151231257827021181583404541015625
     ```

     (An approximation!)
3. Every addition accumulates a tiny error.
4. After the loop, `x` is **very close** to `1.0` but not exactly, so:

   ```python
   x == 1  # False
   ```
5. Printing shows:

   ```
   0.9999999999999999 == 1.0
   ```

💡 **Lesson**: You can’t reliably compare floats with `==` for equality.

---

## **Part 2 – Integers in Binary**

Integers are stored exactly.

Example code from Lecture 4 (slightly adapted here):

```python
if num < 0:
    is_neg = True
    num = abs(num)
else:
    is_neg = False

result = ''
if num == 0:
    result = '0'

while num > 0:
    result = str(num % 2) + result
    num = num // 2

if is_neg:
    result = '-' + result

print(result)
```

**What it does**:

* Converts an integer to its **binary representation**.
* Uses repeated division by 2 (`// 2`) to get bits from right to left.
##### Difference between / and //
`/ `→ true division, result is a float (even if divisible exactly).

```python
5 / 2  # 2.5

# // → floor division, result is the largest integer ≤ the exact division result.

5 // 2  # 2
7 // 3  # 2
-7 // 3 # -3  (because it floors toward negative infinity)
```
Example: `num = 6`:

* `6 % 2 = 0`, num → 3
* `3 % 2 = 1`, num → 1
* `1 % 2 = 1`, num → 0
* Binary (reverse order) = `110`.

Integers are **straightforward** — no rounding issues.

---

## **Part 3 – Fractions in Binary**

Fractions are trickier.

In decimal:

```
0.abc = a × 10⁻¹ + b × 10⁻² + c × 10⁻³
```

In binary:

```
0.abc₂ = a × 2⁻¹ + b × 2⁻² + c × 2⁻³ ...
```

Example:

```
0.375 = 3/8
Multiply by 2³ → 3 (integer)
Binary of 3 = 11
Shift point back 3 → 0.011₂
```

---

## **Part 4 – When it fails**

Some fractions (like `1/10`) never terminate in binary:

* `0.1` in binary = `0.000110011001100110011...` (repeats forever)
* We **cut it off** after a fixed number of bits → rounding.

---

## **Part 5 – Code from slides for finding binary representation**

```python
x = 0.625

p = 0
while ((2**p) * x) % 1 != 0:
    print('Remainder = ' + str((2**p) * x - int((2**p) * x)))
    p += 1

num = int(x * (2**p))

result = ''
if num == 0:
    result = '0'
while num > 0:
    result = str(num % 2) + result
    num = num // 2

for i in range(p - len(result)):
    result = '0' + result

result = result[0:-p] + '.' + result[-p:]
print('The binary representation of the decimal ' + str(x) + ' is ' + str(result))
```

### Walkthrough:

* `p` = how many times we multiply by 2 until we get an integer.
* For `0.625`:

  1. Multiply by 2: 1.25 → remainder .25 → not integer.
  2. Multiply by 2 again: 2.5 → remainder .5 → not integer.
  3. Multiply by 2 again: 5.0 → remainder 0 → integer!
     ⇒ p = 3.
* Convert integer part (5) to binary: `101`.
* Pad with zeros if needed, and insert decimal point 3 places from right: `0.101₂`.

✅ Confirms: `0.625` is exactly representable.

---

## **Part 6 – Storing floats (conceptual model)**

Floating-point numbers = **(significand, exponent)** in base 2.

Examples:

* `(1, 1)` → `1 × 2¹ = 2`
* `(1, -1)` → `1 × 2⁻¹ = 0.5`
* `(125, -2)` → `125 × 2⁻² = 31.25`

---

## **Part 7 – Precision limits**

* Binary32 → 23 bits of fraction ≈ 7 decimal digits.
* Binary64 → 52 bits of fraction ≈ 15–16 decimal digits.
* Numbers needing more bits are **rounded** at the last bit.

---

## **Part 8 – Surprising result code**

```python
x = 0
for i in range(10):
    x += 0.125
print(x == 1.25)  # True

x = 0
for i in range(10):
    x += 0.1
print(x == 1)  # False
print(x, '==', 10*0.1)
```

* `0.125` (1/8) = finite binary, no error.
* `0.1` = repeating binary, error accumulates.

---

## **Part 9 – Moral**

Never use `==` for floats:

```python
abs(a - b) < epsilon
```

---

## **Part 10 – Approximation method**

Goal: approximate `sqrt(x)`.

```python
x = 36
epsilon = 0.01
num_guesses = 0
guess = 0.0
increment = 0.0001

while abs(guess**2 - x) >= epsilon:
    guess += increment
    num_guesses += 1

print('num_guesses =', num_guesses)
print(guess, 'is close to square root of', x)
```

Explanation:

* Start at 0.0, increase by small steps.
* Stop when `guess**2` is within `epsilon` of `x`.
* **Trade-off**:

  * Small `increment` → accurate but slow.
  * Large `increment` → fast but less accurate.

---

## **Part 11 – Overshooting fix**

We can skip over the “close enough” zone entirely:

```python
while abs(guess**2 - x) >= epsilon and guess**2 <= x:
    guess += increment
```

Stops if:

* You’re close enough, OR
* You’ve gone past the target.

---

## **Part 12 – Lessons**

* Floats can’t store all decimals exactly.
* Don’t compare with `==`.
* Approximation needs careful tuning (epsilon & increment).
* Guard against overshooting.

---

If you want, I can now **run all of these code snippets** from the lecture in sequence and print the actual Python outputs so you see exactly where errors happen and how epsilon affects runtime. That would be like "live coding" the slides.

Do you want me to do that next?
