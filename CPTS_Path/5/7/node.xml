<?xml version="1.0" encoding="UTF-8"?>
<cherrytree>
  <node unique_id="7" master_id="0" name="Windows Assembly" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="121" is_bold="0" foreground="" ts_creation="1750870698" ts_lastsave="1750872259">
    <rich_text>
</rich_text>
    <rich_text scale="h3" weight="heavy">There are 8 main general-purpose registers:</rich_text>
    <rich_text> 
	</rich_text>
    <rich_text family="monospace" weight="heavy">RAX</rich_text>
    <rich_text family="monospace"> - Known as the accumulator register. Often used to store the return value of a function.
	</rich_text>
    <rich_text family="monospace" weight="heavy">RBX</rich_text>
    <rich_text family="monospace"> - Sometimes known as the base register, not to be confused with the base pointer. Sometimes used as a base pointer for memory access.
	</rich_text>
    <rich_text family="monospace" weight="heavy">RDX</rich_text>
    <rich_text family="monospace"> - Sometimes known as the data register.
	</rich_text>
    <rich_text family="monospace" weight="heavy">RCX</rich_text>
    <rich_text family="monospace"> - Sometimes known as the counter register. Used as a loop counter.
	</rich_text>
    <rich_text family="monospace" weight="heavy">RSI</rich_text>
    <rich_text family="monospace"> - Known as the source index. Used as the source pointer in string operations.
	</rich_text>
    <rich_text family="monospace" weight="heavy">RDI</rich_text>
    <rich_text family="monospace"> - Known as the destination index. Used as the destination pointer in string operations.
	</rich_text>
    <rich_text family="monospace" weight="heavy">RSP</rich_text>
    <rich_text family="monospace"> - The stack pointer. Holds the address of the top of the stack.
	</rich_text>
    <rich_text family="monospace" weight="heavy">RBP</rich_text>
    <rich_text family="monospace"> - The base pointer. Holds the address of the base (bottom) of the stack.
</rich_text>
    <rich_text>

</rich_text>
    <rich_text scale="h1">Extra Registers </rich_text>
    <rich_text>

    </rich_text>
    <rich_text weight="heavy">R8</rich_text>
    <rich_text> - Full 64-bit (8 bytes) register.
    </rich_text>
    <rich_text weight="heavy">R8D</rich_text>
    <rich_text> - Lower double word (4 bytes).
    </rich_text>
    <rich_text weight="heavy">R8W</rich_text>
    <rich_text> - Lower word (2 bytes)
    </rich_text>
    <rich_text weight="heavy">R8B</rich_text>
    <rich_text> - Lower byte.



</rich_text>
    <rich_text scale="h1">Instructions </rich_text>
    <rich_text>
 </rich_text>
    <rich_text family="monospace">   - An immediate value (or just immediate, sometimes IM) is something like the number 12.
    			 An immediate 
    				value is not a  memory address or register, instead, it's some sort of constant data.
    - A register is referring to something like RAX, RBX, R12, AL, etc.
    - Memory or a memory address refers to a location in memory (a memory address) such as 0x7FFF842B.</rich_text>
    <rich_text>

#</rich_text>
    <rich_text scale="h3">FORMAT</rich_text>
    <rich_text>
					(Instruction/Opcode/Mnemonic) &lt;Destination Operand&gt;, &lt;Source Operand&gt; 
					
# INSTRUCTIONS

					mov RAX, 5       						=&gt; RAX = 1
					lea RAX, num1                     =&gt;   addressof(num1)
					
					
					
# Flipping Out
					
					what we write :
												
											</rich_text>
    <rich_text foreground="#26a269">	if(x == 4){
													func1();
												}
												else{
													return;
												}</rich_text>
    <rich_text>
					What Compliler Generates :
											
											</rich_text>
    <rich_text foreground="#26a269">if(x != 4){
												goto __exit;
											}
											func1();
											__exit:
											return;</rich_text>
    <rich_text>

				# Compiler is all about efficiency.
				
				

</rich_text>
    <rich_text scale="h2">Pointers</rich_text>
    <rich_text>
</rich_text>
    <rich_text weight="heavy">Square Brackets -</rich_text>
    <rich_text> Square brackets dereference in assembly. For example, [var] is the address pointed to by var. In other words, when using [var] we want to access the memory address that var is holding.


					MOV RAX, [10]              </rich_text>
    <rich_text foreground="#26a269">;RAX = *(0xA)    =&gt; Dereference Value at this address.</rich_text>
    <rich_text>
					LEA RAX,[10]                </rich_text>
    <rich_text foreground="#26a269"> ; RAX = 10         =&gt; It does not read from memory â€” it's like saying "RAX = address 10".</rich_text>
    <rich_text>
					
					
					
</rich_text>
    <rich_text weight="heavy">					let RCX =  0x1000</rich_text>
    <rich_text>
	                LEA RAX, [RCX + 8]       </rich_text>
    <rich_text foreground="#26a269"> ; RAX = 0x1000 + 8 = 0x1008</rich_text>
    <rich_text>
					</rich_text>
    <rich_text style="italic">No memory read happens here. RAX just ends up with the computed address (0x1008).</rich_text>
    <rich_text>
	
					let RCX = 0x1000
					let Memory at 0x1008 = 0x12345678
					
					MOV RAX, [RCX + 8]   		</rich_text>
    <rich_text foreground="#26a269">; RAX = *(0x1000 + 8) = *(0x1008)</rich_text>
    <rich_text>
																</rich_text>
    <rich_text foreground="#26a269"> ; RAX = 0x12345678</rich_text>
    <rich_text>
	
 
</rich_text>
    <rich_text weight="heavy">LEA </rich_text>
    <rich_text>- Ignore everything about square brackets when working with LEA. LEA is short for Load Effective Address and it's used for calculating and loading addresses.


</rich_text>
    <rich_text scale="h1">The JMP's Mason</rich_text>
    <rich_text>

</rich_text>
    <rich_text weight="heavy">For unsigned comparisons:</rich_text>
    <rich_text>

    JB/JNAE (CF = 1) ; Jump if below/not above or equal

    JAE/JNB (CF = 0) ; Jump if above or equal/not below

    JBE/JNA (CF = 1 or ZF = 1) ; Jump if below or equal/not above

    JA/JNBE (CF = 0 and ZF = 0); Jump if above/not below or equal

</rich_text>
    <rich_text weight="heavy">For signed comparisons:</rich_text>
    <rich_text>

	JL/JNGE (SF &lt;&gt; OF) ; Jump if less/not greater or equal

	JGE/JNL (SF = OF) ; Jump if greater or equal/not less

	JLE/JNG (ZF = 1 or SF &lt;&gt; OF); Jump if less or equal/not greater

	JG/JNLE (ZF = 0 and SF = OF); Jump if greater/not less or equal</rich_text>
  </node>
</cherrytree>
